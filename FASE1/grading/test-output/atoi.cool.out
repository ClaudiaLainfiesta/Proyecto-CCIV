'('
'*'
TYPEID The
CLASS
TYPEID A2I
OBJECTID provides
OBJECTID integer
'-'
OBJECTID to
'-'
OBJECTID string
OBJECTID and
OBJECTID string
'-'
OBJECTID to
'-'
OBJECTID integer
OBJECTID conversion
OBJECTID routines
'.'
TYPEID To
OBJECTID use
OBJECTID these
OBJECTID routines
','
OBJECTID either
OBJECTID inherit
OBJECTID them
IN
OBJECTID the
CLASS
OBJECTID where
OBJECTID needed
','
OBJECTID have
OBJECTID a
OBJECTID dummy
OBJECTID variable
OBJECTID bound
OBJECTID to
OBJECTID something
OF
OBJECTID type
TYPEID A2I
','
OBJECTID or
OBJECTID simpl
OBJECTID write
'('
OBJECTID new
TYPEID A2I
')'
'.'
OBJECTID method
'('
OBJECTID argument
')'
'.'
'*'
')'
'('
'*'
OBJECTID c2i
TYPEID Converts
OBJECTID a
INT_CONST 1
'-'
OBJECTID character
OBJECTID string
OBJECTID to
OBJECTID an
OBJECTID integer
'.'
TYPEID Aborts
IF
OBJECTID the
OBJECTID string
OBJECTID is
NOT
STR_CONST "0"
OBJECTID through
STR_CONST "9"
'*'
')'
CLASS
TYPEID A2I
'{'
OBJECTID c2i
'('
OBJECTID char
':'
TYPEID String
')'
':'
TYPEID Int
'{'
IF
OBJECTID char
'='
STR_CONST "0"
OBJECTID then
INT_CONST 0
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "1"
OBJECTID then
INT_CONST 1
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "2"
OBJECTID then
INT_CONST 2
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "3"
OBJECTID then
INT_CONST 3
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "4"
OBJECTID then
INT_CONST 4
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "5"
OBJECTID then
INT_CONST 5
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "6"
OBJECTID then
INT_CONST 6
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "7"
OBJECTID then
INT_CONST 7
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "8"
OBJECTID then
INT_CONST 8
OBJECTID else
IF
OBJECTID char
'='
STR_CONST "9"
OBJECTID then
INT_CONST 9
OBJECTID else
'{'
OBJECTID abort
'('
')'
';'
INT_CONST 0
';'
'}'
'-'
'-'
OBJECTID the
INT_CONST 0
OBJECTID is
OBJECTID needed
OBJECTID to
OBJECTID satisfy
OBJECTID the
OBJECTID typchecker
FI
FI
FI
FI
FI
FI
FI
FI
FI
FI
'}'
';'
'('
'*'
OBJECTID i2c
OBJECTID is
OBJECTID the
OBJECTID inverse
OF
OBJECTID c2i
'.'
'*'
')'
OBJECTID i2c
'('
OBJECTID i
':'
TYPEID Int
')'
':'
TYPEID String
'{'
IF
OBJECTID i
'='
INT_CONST 0
OBJECTID then
STR_CONST "0"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 1
OBJECTID then
STR_CONST "1"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 2
OBJECTID then
STR_CONST "2"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 3
OBJECTID then
STR_CONST "3"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 4
OBJECTID then
STR_CONST "4"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 5
OBJECTID then
STR_CONST "5"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 6
OBJECTID then
STR_CONST "6"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 7
OBJECTID then
STR_CONST "7"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 8
OBJECTID then
STR_CONST "8"
OBJECTID else
IF
OBJECTID i
'='
INT_CONST 9
OBJECTID then
STR_CONST "9"
OBJECTID else
'{'
OBJECTID abort
'('
')'
';'
STR_CONST ""
';'
'}'
'-'
'-'
OBJECTID the
STR_CONST ""
OBJECTID is
OBJECTID needed
OBJECTID to
OBJECTID satisfy
OBJECTID the
OBJECTID typchecker
FI
FI
FI
FI
FI
FI
FI
FI
FI
FI
'}'
';'
'('
'*'
OBJECTID a2i
OBJECTID converts
OBJECTID an
TYPEID ASCII
OBJECTID string
OBJECTID into
OBJECTID an
OBJECTID integer
'.'
TYPEID The
OBJECTID empty
OBJECTID string
OBJECTID is
OBJECTID converted
OBJECTID to
INT_CONST 0
'.'
TYPEID Signed
OBJECTID and
OBJECTID unsigned
OBJECTID strings
OBJECTID are
OBJECTID handled
'.'
TYPEID The
OBJECTID method
OBJECTID aborts
IF
OBJECTID the
OBJECTID string
OBJECTID does
NOT
OBJECTID represent
OBJECTID an
OBJECTID integer
'.'
TYPEID Very
OBJECTID long
OBJECTID strings
OF
OBJECTID digits
OBJECTID produce
OBJECTID strange
OBJECTID answers
OBJECTID because
OF
OBJECTID arithmetic
OBJECTID overflow
'.'
'*'
')'
OBJECTID a2i
'('
OBJECTID s
':'
TYPEID String
')'
':'
TYPEID Int
'{'
IF
OBJECTID s
'.'
OBJECTID length
'('
')'
'='
INT_CONST 0
OBJECTID then
INT_CONST 0
OBJECTID else
IF
OBJECTID s
'.'
OBJECTID substr
'('
INT_CONST 0
','
INT_CONST 1
')'
'='
STR_CONST "-"
OBJECTID then
'~'
OBJECTID a2i
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID s
'.'
OBJECTID substr
'('
INT_CONST 1
','
OBJECTID s
'.'
OBJECTID length
'('
')'
'-'
INT_CONST 1
')'
')'
OBJECTID else
IF
OBJECTID s
'.'
OBJECTID substr
'('
INT_CONST 0
','
INT_CONST 1
')'
'='
STR_CONST "+"
OBJECTID then
OBJECTID a2i
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID s
'.'
OBJECTID substr
'('
INT_CONST 1
','
OBJECTID s
'.'
OBJECTID length
'('
')'
'-'
INT_CONST 1
')'
')'
OBJECTID else
OBJECTID a2i
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID s
')'
FI
FI
FI
'}'
';'
'('
'*'
OBJECTID a2i
LEXER BUG - UNMATCHED: _
OBJECTID aux
OBJECTID converts
OBJECTID the
OBJECTID usigned
OBJECTID portion
OF
OBJECTID the
OBJECTID string
'.'
TYPEID As
OBJECTID a
OBJECTID programming
OBJECTID example
','
OBJECTID this
OBJECTID method
OBJECTID is
OBJECTID written
OBJECTID iteratively
'.'
'*'
')'
OBJECTID a2i
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID s
':'
TYPEID String
')'
':'
TYPEID Int
'{'
'('
OBJECTID let
OBJECTID int
':'
TYPEID Int
ASSIGN
INT_CONST 0
IN
'{'
'('
OBJECTID let
OBJECTID j
':'
TYPEID Int
ASSIGN
OBJECTID s
'.'
OBJECTID length
'('
')'
IN
'('
OBJECTID let
OBJECTID i
':'
TYPEID Int
ASSIGN
INT_CONST 0
IN
OBJECTID while
OBJECTID i
'<'
OBJECTID j
LOOP
'{'
OBJECTID int
ASSIGN
OBJECTID int
'*'
INT_CONST 10
'+'
OBJECTID c2i
'('
OBJECTID s
'.'
OBJECTID substr
'('
OBJECTID i
','
INT_CONST 1
')'
')'
';'
OBJECTID i
ASSIGN
OBJECTID i
'+'
INT_CONST 1
';'
'}'
POOL
')'
')'
';'
OBJECTID int
';'
'}'
')'
'}'
';'
'('
'*'
OBJECTID i2a
OBJECTID converts
OBJECTID an
OBJECTID integer
OBJECTID to
OBJECTID a
OBJECTID string
'.'
TYPEID Positive
OBJECTID and
OBJECTID negative
OBJECTID numbers
OBJECTID are
OBJECTID handled
OBJECTID correctly
'.'
'*'
')'
OBJECTID i2a
'('
OBJECTID i
':'
TYPEID Int
')'
':'
TYPEID String
'{'
IF
OBJECTID i
'='
INT_CONST 0
OBJECTID then
STR_CONST "0"
OBJECTID else
IF
INT_CONST 0
'<'
OBJECTID i
OBJECTID then
OBJECTID i2a
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID i
')'
OBJECTID else
STR_CONST "-"
'.'
OBJECTID concat
'('
OBJECTID i2a
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID i
'*'
'~'
INT_CONST 1
')'
')'
FI
FI
'}'
';'
'('
'*'
OBJECTID i2a
LEXER BUG - UNMATCHED: _
OBJECTID aux
OBJECTID is
OBJECTID an
OBJECTID example
OBJECTID using
OBJECTID recursion
'.'
'*'
')'
OBJECTID i2a
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID i
':'
TYPEID Int
')'
':'
TYPEID String
'{'
IF
OBJECTID i
'='
INT_CONST 0
OBJECTID then
STR_CONST ""
OBJECTID else
'('
OBJECTID let
OBJECTID next
':'
TYPEID Int
ASSIGN
OBJECTID i
'/'
INT_CONST 10
IN
OBJECTID i2a
LEXER BUG - UNMATCHED: _
OBJECTID aux
'('
OBJECTID next
')'
'.'
OBJECTID concat
'('
OBJECTID i2c
'('
OBJECTID i
'-'
OBJECTID next
'*'
INT_CONST 10
')'
')'
')'
FI
'}'
';'
'}'
';'
